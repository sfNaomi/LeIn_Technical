"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Parse Metadata WSDL.
 *
 * @param metadataWSDL - already parsed XML Metadata WSDL.
 *
 * @author Ondřej Kratochvíl
 */
function parseMetadataWSDL(metadataWSDL) {
    var complexTypes = metadataWSDL.definitions.types[0]["xsd:schema"][0]["xsd:complexType"];
    var simpleTypes = metadataWSDL.definitions.types[0]["xsd:schema"][0]["xsd:simpleType"];
    var elements = metadataWSDL.definitions.types[0]["xsd:schema"][0]["xsd:element"];
    console.log("XSD complex types: " + complexTypes.length);
    console.log("XSD simple types: " + simpleTypes.length);
    console.log("XSD elements: " + elements.length);
    var parsed = [
        parseTypesFromElements(elements),
        parseTypesFromSimpleTypes(simpleTypes),
        parseTypesFromComplexTypes(complexTypes)
    ].reduce(function (result, it) { return ({
        complexTypes: result.complexTypes.concat(it.complexTypes),
        simpleTypes: result.simpleTypes.concat(it.simpleTypes)
    }); }, { complexTypes: [], simpleTypes: [] });
    console.log("Complex types: " + parsed.complexTypes.length);
    console.log("Simple types: " + parsed.simpleTypes.length);
    return parsed;
}
exports.parseMetadataWSDL = parseMetadataWSDL;
function parseStringType(type) {
    if (type.startsWith("xsd:")) {
        return type.substring(4);
    }
    else if (type.startsWith("tns:")) {
        return type.substring(4);
    }
    throw Error("Unknown wsdl type " + type);
}
function parseTypesFromSimpleTypes(simpleTypes) {
    return simpleTypes
        .sort(function (a, b) { return a.$.name.localeCompare(b.$.name); })
        .reduce(function (result, it) {
        var name = it.$.name;
        var restriction = it["xsd:restriction"][0];
        var base = parseStringType(restriction.$.base);
        var enumerations = restriction["xsd:enumeration"];
        var length = restriction["xsd:length"];
        var pattern = restriction["xsd:pattern"];
        if (enumerations) {
            result.simpleTypes.push({ name: name, base: base, enumerations: enumerations.map(function (e) { return e.$.value; }) });
        }
        else if (length && pattern) {
            if (base) {
                result.simpleTypes.push({ name: name, base: base });
            }
            else {
                throw Error("Unsupported simple type: " + JSON.stringify(it, null, 2));
            }
        }
        else {
            result.simpleTypes.push({ name: name, base: base });
        }
        return result;
    }, { complexTypes: [], simpleTypes: [] });
}
function parseTypesFromComplexTypes(complexTypes) {
    return complexTypes
        .sort(function (a, b) { return a.$ && b.$ ? a.$.name.localeCompare(b.$.name) : 0; })
        .reduce(function (result, it) {
        if (!it.$) {
            return result;
        }
        var name = it.$.name;
        var sequences = it["xsd:sequence"];
        var complexContents = it["xsd:complexContent"];
        if (sequences) {
            var sequenceElements = sequences[0]["xsd:element"];
            if (sequenceElements) {
                result.complexTypes.push({ name: name, elements: createPropertiesFromSequenceElements(sequenceElements) });
            }
        }
        else if (complexContents) {
            var extension = complexContents[0]["xsd:extension"][0];
            var base = parseStringType(extension.$.base);
            var extensionSequence = extension["xsd:sequence"][0];
            var sequenceElements = extensionSequence["xsd:element"];
            var elements = sequenceElements
                ? createPropertiesFromSequenceElements(sequenceElements)
                : [];
            result.complexTypes.push({ name: name, elements: elements, base: base });
        }
        return result;
    }, { complexTypes: [], simpleTypes: [] });
}
function parseTypesFromElements(elements) {
    return elements.reduce(function (result, el) {
        if (el["xsd:complexType"] && el["xsd:complexType"][0]["xsd:sequence"]) {
            var sequence = el["xsd:complexType"][0]["xsd:sequence"][0];
            var sequenceElements = sequence["xsd:element"];
            result.complexTypes.push({
                name: el.$.name,
                elements: createPropertiesFromSequenceElements(sequenceElements)
            });
        }
        return result;
    }, { complexTypes: [], simpleTypes: [] });
}
function createPropertiesFromSequenceElements(sequenceElements) {
    return sequenceElements.reduce(function (result, el) {
        if (el.$.type) {
            var isArray = Boolean(el.$.maxOccurs && el.$.maxOccurs === "unbounded");
            var isOptional = Boolean(el.$.minOccurs && el.$.minOccurs === "0");
            result.push({ name: el.$.name, type: parseStringType(el.$.type), isArray: isArray, isOptional: isOptional });
        }
        else {
            console.warn("Sequence element without type: " + JSON.stringify(el, null, 2));
        }
        return result;
    }, []);
}
//# sourceMappingURL=wsdl-parser.js.map