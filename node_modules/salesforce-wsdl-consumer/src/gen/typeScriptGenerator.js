"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_extra_1 = __importDefault(require("fs-extra"));
var __1 = require("..");
var index_1 = require("../index");
var resources_1 = require("../resources");
/**
 * Generate TypeScript types from Metadata WSDL.
 * See [example result]{@link https://github.com/kratoon3/salesforce-metadata/blob/master/src/metadata-types.ts}.
 *
 * @param options - Set latest or metadataVersion if you want to use this project's WSDL.
 * If latest is set, metadataVersion and metadataWsdlPath are ignored.
 * If metadataVersion is set, metadataWsdlPath is ignored.
 * You can override default 'metadata-types.ts' output file with outputFile.
 *
 * @author  Ondřej Kratochvíl
 */
function generateTypesFromMetadataWSDL(options) {
    if (options === void 0) { options = {
        outputFile: "metadata-types.ts",
        latest: true
    }; }
    function getMetadataWSDL() {
        if (options.latest) {
            return resources_1.readMetadataWSDLByVersion(index_1.LATEST_METADATA_VERSION);
        }
        else if (options.metadataVersion) {
            return resources_1.readMetadataWSDLByVersion(options.metadataVersion);
        }
        else if (options.metadataWsdlPath) {
            return resources_1.readMetadataWSDLFromPath(options.metadataWsdlPath);
        }
        return resources_1.readMetadataWSDLByVersion(index_1.LATEST_METADATA_VERSION);
    }
    var outputFile = options.outputFile || "metadata-types.ts";
    fs_extra_1.default.ensureFileSync(outputFile);
    return getMetadataWSDL()
        .then(function (wsdl) { return fs_extra_1.default.writeFile(outputFile, buildScript(__1.parseMetadataWSDL(wsdl))); });
}
exports.generateTypesFromMetadataWSDL = generateTypesFromMetadataWSDL;
function firstLetterToUpperCase(str) {
    return str ? str.charAt(0).toUpperCase() + str.slice(1) : str;
}
function getType(element) {
    var mapping = {
        int: "number",
        boolean: "boolean",
        string: "string",
        double: "number",
        long: "number",
        date: "string",
        dateTime: "string",
        time: "number",
        base64Binary: "any",
        anyType: "any"
    };
    if (mapping[element.type]) {
        return mapping[element.type];
    }
    return element.type;
}
function getTypeAlwaysArray(element) {
    var type = getType(element);
    return type && !type.includes("[]") ? type + "[]" : type;
}
function buildInterface(type) {
    var extend = type.base ? " extends " + type.base : "";
    var result = "export interface " + firstLetterToUpperCase(type.name) + extend + " {\n";
    for (var _i = 0, _a = type.elements || []; _i < _a.length; _i++) {
        var property = _a[_i];
        var propertyType = getTypeAlwaysArray(property);
        if (!propertyType) {
            throw Error("Unknown property type [" + propertyType + "]");
        }
        result += "    " + property.name + "?: " + propertyType + ";\n";
    }
    result += "}\n";
    return result;
}
function buildType(type) {
    if (type.enumerations) {
        return "export type " + type.name + " = " + type.enumerations.map(function (it) { return "\"" + it + "\""; }).join(" | ") + ";\n";
    }
    else if (type.base) {
        return "export type " + type.name + " = " + type.base + ";\n";
    }
    throw new Error("Unknown simple type without enumerations and/or base.");
}
function buildMetadataType(metadataTypes) {
    return "export type MetadataType = \n" + metadataTypes.map(function (it) { return "\t\"" + it.name + "\""; }).join(" |\n") + ";\n";
}
function buildMetadataTypeArray(metadataTypes) {
    return "export const metadataTypes: MetadataType[] = [\n" + metadataTypes.map(function (it) { return "\t\"" + it.name + "\","; }).join("\n") + "\n];\n";
}
function filterMetadataTypes(complexTypes) {
    var nameToIsMetadata = mapComplexTypeNameToIsMetadata(complexTypes);
    return complexTypes.filter(function (it) { return nameToIsMetadata[it.name]; });
}
function mapComplexTypeNameToIsMetadata(complexTypes) {
    var result = { Metadata: true };
    var found = 1;
    while (found !== complexTypes.length) {
        for (var _i = 0, complexTypes_1 = complexTypes; _i < complexTypes_1.length; _i++) {
            var it_1 = complexTypes_1[_i];
            if (result[it_1.name] === undefined) {
                if (!it_1.base || (it_1.base && result[it_1.base] === false)) {
                    result[it_1.name] = false;
                    ++found;
                }
                else if (it_1.base && result[it_1.base]) {
                    result[it_1.name] = true;
                    ++found;
                }
            }
        }
    }
    return result;
}
function buildScript(parsedMetadataWSDL) {
    var tslintDisabled = "/* tslint:disable */\n";
    var notice = "/* This file was created via \"salesforce-wsdl-consumer\".\nDo not make any changes here as it can be anytime regenerated. \nProject: https://github.com/kratoon3/salesforce-wsdl-consumer\nIssues: https://github.com/kratoon3/salesforce-wsdl-consumer/issues */\n\n";
    var typeScriptTypes = parsedMetadataWSDL.simpleTypes.map(buildType);
    var typeScriptInterfaces = parsedMetadataWSDL.complexTypes.map(buildInterface);
    var metadataTypes = filterMetadataTypes(parsedMetadataWSDL.complexTypes);
    console.log("Metadata types: ", metadataTypes.length);
    return [
        tslintDisabled,
        notice,
        typeScriptTypes.join(""),
        typeScriptInterfaces.join("\n"),
        buildMetadataType(metadataTypes),
        buildMetadataTypeArray(metadataTypes)
    ].join("\n");
}
//# sourceMappingURL=typeScriptGenerator.js.map