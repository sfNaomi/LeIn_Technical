"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = require("path");
const salesforce_metadata_1 = require("salesforce-metadata");
const find_metadata_1 = require("salesforce-metadata/src/find-metadata");
const slash_1 = tslib_1.__importDefault(require("slash"));
const project_1 = require("../../project");
const notice_1 = require("./notice");
function generateRecordTypesClass(options = {}) {
    const project = project_1.loadProject(options.projectDir || ".");
    if (!project.isDx) {
        throw Error("Only DX projects are currently supported.");
    }
    // Get options with default values.
    const outputDir = options.outputDir || project.join(project.sfdxDefaultProjectDirectory, "main", "default", "classes");
    const outputClassName = options.outputClassName || "RecordTypes";
    const sourceApiVersion = options.sourceApiVersion || project.sourceApiVersion;
    const activeOnly = options.includeInactive === undefined ? true : !options.includeInactive;
    const tests = options.ignoreTestClass === undefined ? true : !options.ignoreTestClass;
    const trimCustomSuffix = true;
    // Find paths to project record types.
    const recordTypePaths = find_metadata_1.findCustomObjectChildFiles("recordType", project.path);
    buildContent(recordTypePaths, activeOnly, trimCustomSuffix, outputClassName)
        .then((content) => {
        const classPath = path_1.join(outputDir, `${outputClassName}.cls`);
        console.log(`Writing record types to ${classPath}`);
        writeApexClassFile(classPath, content);
        const metaPath = path_1.join(outputDir, `${outputClassName}.cls-meta.xml`);
        console.log(`Writing meta file for class to ${metaPath}`);
        writeApexClassMetaFile(metaPath, sourceApiVersion);
    });
    if (tests) {
        buildTestContent(recordTypePaths, activeOnly, trimCustomSuffix, outputClassName).then((content) => {
            const classPath = path_1.join(outputDir, `${outputClassName}Test.cls`);
            console.log(`Writing record types test to ${classPath}`);
            writeApexClassFile(classPath, content);
            const metaPath = path_1.join(outputDir, `${outputClassName}Test.cls-meta.xml`);
            console.log(`Writing meta file for test class to ${metaPath}`);
            writeApexClassMetaFile(metaPath, sourceApiVersion);
        });
    }
}
exports.generateRecordTypesClass = generateRecordTypesClass;
function writeApexClassFile(path, content) {
    fs_extra_1.default.ensureFileSync(path);
    fs_extra_1.default.writeFileSync(path, content);
}
function writeApexClassMetaFile(path, apiVersion) {
    const data = {
        ApexClass: {
            $: {
                xmlns: "http://soap.sforce.com/2006/04/metadata"
            },
            // @ts-ignore
            apiVersion: apiVersion,
            status: ["Active"]
        }
    };
    salesforce_metadata_1.writeMetadataXML(path, data);
}
function buildContent(recordTypePaths, activeOnly, trimCustomSuffix, className) {
    return recordTypePaths
        .reduce((content, path) => {
        return content.then((allResult) => {
            return salesforce_metadata_1.readMetadataXML(path).then((recordType) => {
                if (activeOnly && !recordType.RecordType.active) {
                    return allResult;
                }
                const objectName = pathToObjectName(path);
                if (!objectName) {
                    throw Error(`Couldn't parse object name from path ${path}`);
                }
                return allResult + buildRecordTypeProperty(recordType, objectName, trimCustomSuffix);
            });
        });
    }, Promise.resolve(""))
        .then((classContent) => {
        return `${notice_1.apexNotice()}public inherited sharing class ${className} {\n\n${classContent}}\n`;
    });
}
function buildTestContent(recordTypePaths, activeOnly, trimCustomSuffix, className) {
    return recordTypePaths
        .reduce((content, path) => {
        return content.then((allResult) => {
            return salesforce_metadata_1.readMetadataXML(path).then((recordType) => {
                if (activeOnly && !recordType.RecordType.active) {
                    return allResult;
                }
                const objectName = pathToObjectName(path);
                if (!objectName) {
                    throw Error(`Couldn't parse object name from path ${path}`);
                }
                return allResult + buildTestRecordTypeProperty(recordType, objectName, className, trimCustomSuffix);
            });
        });
    }, Promise.resolve(""))
        .then((classContent) => buildTestClassContent(classContent, className));
}
function buildTestClassContent(classContent, className) {
    return `${notice_1.apexNotice()}@IsTest private class ${className}Test {

    private static void notNull(Object it) {
        System.assertNotEquals(null, it);
    }
    
    @IsTest private static void test() {
${classContent}    }
}`;
}
function buildRecordTypeProperty(recordType, objectName, trimCustomSuffix) {
    const { fullName } = recordType.RecordType;
    if (!fullName || fullName.length === 0) {
        throw Error(`Record type without full name ${recordType}`);
    }
    const objName = trimCustomSuffix ? objectName.replace("__c", "") : objectName;
    const propertyName = `${objName}_${fullName}`.toUpperCase();
    const idPropertyName = `${propertyName}_ID`;
    return `    public static RecordTypeInfo ${propertyName} {
        get { return ${propertyName} = ${propertyName} != null
                ? ${propertyName} : Schema.SObjectType.${objectName}.getRecordTypeInfosByDeveloperName().get('${fullName[0]}'); }
        private set;
    }
    public static Id ${idPropertyName} {
        get { return ${propertyName}.getRecordTypeId(); }
        private set;
    }
`;
}
function buildTestRecordTypeProperty(recordType, objectName, className, trimCustomSuffix) {
    const { fullName } = recordType.RecordType;
    if (!fullName || fullName.length === 0) {
        throw Error(`Record type without full name ${recordType}`);
    }
    const objName = trimCustomSuffix ? objectName.replace("__c", "") : objectName;
    const propertyName = `${objName}_${fullName}`.toUpperCase();
    const idPropertyName = `${propertyName}_ID`;
    return `        notNull(${className}.${idPropertyName});\n`;
}
function pathToObjectName(path) {
    const execResult = slash_1.default(path).match(/.*[/\\]objects[/\\](.*?)[/\\].*/);
    return execResult ? execResult[1] : undefined;
}
//# sourceMappingURL=record-types.js.map