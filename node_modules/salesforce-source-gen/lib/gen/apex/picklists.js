"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = require("path");
const salesforce_metadata_1 = require("salesforce-metadata");
const find_metadata_1 = require("salesforce-metadata/src/find-metadata");
const slash_1 = tslib_1.__importDefault(require("slash"));
const project_1 = require("../../project");
const notice_1 = require("./notice");
const APEX_CLASS_NAME_MAX_LEN = 40;
const CONFLICT_VALUE_SET_NAMES = ["LeadStatus"];
function generatePicklistClasses(options = {}) {
    var _a, _b, _c;
    const project = project_1.loadProject(options.projectDir || ".");
    if (!project.isDx) {
        throw Error("Only DX projects are supported.");
    }
    // Get options with default values.
    const outputDir = options.outputDir || project.join(project.sfdxDefaultProjectDirectory, "main", "default", "classes");
    const sourceApiVersion = options.sourceApiVersion || project.sourceApiVersion;
    const customFieldPrefix = options.customFieldPrefix || "";
    const customFieldSuffix = options.customFieldSuffix || "";
    const customFieldInfix = options.customFieldInfix || "_";
    const standardValueSetPrefix = options.standardValueSetPrefix || "";
    const standardValueSetSuffix = options.standardValueSetSuffix || "";
    const globalValueSetPrefix = options.globalValueSetPrefix || "";
    const globalValueSetSuffix = options.globalValueSetSuffix || "";
    const include = ((_c = (_b = (_a = project.packageJson) === null || _a === void 0 ? void 0 : _a.sourceGen) === null || _b === void 0 ? void 0 : _b.picklists) === null || _c === void 0 ? void 0 : _c.include) || undefined;
    let chain = Promise.resolve();
    if (!options.ignorePicklists) {
        chain = chain.then(() => generatePicklistClassesFromCustomFields(project, outputDir, include, customFieldInfix, customFieldPrefix, customFieldSuffix, sourceApiVersion));
    }
    if (!options.ignoreStandardValueSets) {
        chain = chain.then(() => generatePicklistClassesFromStandardValueSets(project, outputDir, include, standardValueSetPrefix, standardValueSetSuffix, sourceApiVersion));
    }
    if (!options.ignoreGlobalValueSets) {
        chain.then(() => generatePicklistClassesFromGlobalValueSets(project, outputDir, include, globalValueSetPrefix, globalValueSetSuffix, sourceApiVersion));
    }
}
exports.generatePicklistClasses = generatePicklistClasses;
function generatePicklistClassesFromCustomFields(project, outputDir, include, infix, prefix, suffix, sourceApiVersion) {
    console.log("Building constant classes from custom fields.");
    const customFieldPaths = find_metadata_1.findFilesByMetadataType("CustomField", project.path);
    return Promise.all(customFieldPaths.map(salesforce_metadata_1.readMetadataXML))
        .then((fields) => {
        fields.forEach((it, idx) => {
            if (it.CustomField && it.CustomField.fullName && isFieldWithValueSet(it.CustomField)) {
                const fieldPath = customFieldPaths[idx];
                const objectName = pathToObjectName(fieldPath);
                if (!objectName) {
                    throw Error(`Couldn't parse object name from path ${fieldPath}`);
                }
                const fieldName = it.CustomField.fullName[0];
                if (!include || include.includes(objectName) || include.includes(`${objectName}.${fieldName}`)) {
                    const trimmedObjectName = objectName.replace(/__c|__mdt|_/g, "");
                    const trimmedFieldName = fieldName.replace(/__c|__mdt|_/g, "");
                    const availableLength = APEX_CLASS_NAME_MAX_LEN -
                        (prefix.length + infix.length + suffix.length);
                    const fullBaseName = `${trimmedObjectName}${infix}${trimmedFieldName}`;
                    const baseName = fullBaseName.substring(0, availableLength);
                    const className = `${prefix}${baseName}${suffix}`;
                    const content = buildApexClassContentFromPicklistField(it.CustomField, objectName, className);
                    if (content) {
                        writeApexClassFile(path_1.join(outputDir, `${className}.cls`), content);
                        writeApexClassMetaFile(path_1.join(outputDir, `${className}.cls-meta.xml`), sourceApiVersion);
                    }
                    else {
                        console.log(`No values, skipping: ${objectName}.${fieldName}`);
                    }
                }
            }
        });
    });
}
function generatePicklistClassesFromStandardValueSets(project, outputDir, include, prefix, suffix, sourceApiVersion) {
    const standardValueSetPaths = find_metadata_1.findFilesByMetadataType("StandardValueSet", project.path);
    return Promise.all(standardValueSetPaths.map(salesforce_metadata_1.readMetadataXML))
        .then((sets) => {
        console.log("Building constant classes from standard value sets.");
        sets.forEach((it, idx) => {
            const setPath = standardValueSetPaths[idx];
            let valueSetName = pathToMetadataName(setPath, "standardValueSets", "\.standardValueSet-meta\.xml");
            if (!valueSetName) {
                throw Error(`Couldn't parse standard value set name from path ${setPath}`);
            }
            if (!include || include.includes(valueSetName)) {
                valueSetName = CONFLICT_VALUE_SET_NAMES.includes(valueSetName) ? `${valueSetName}2` : valueSetName;
                const availableLength = APEX_CLASS_NAME_MAX_LEN - (prefix.length + suffix.length);
                const baseName = valueSetName.substring(0, availableLength);
                const className = `${prefix}${baseName}${suffix}`;
                const content = buildApexClassContentFromStandardValueSet(it.StandardValueSet, valueSetName, className);
                if (content) {
                    writeApexClassFile(path_1.join(outputDir, `${className}.cls`), content);
                    writeApexClassMetaFile(path_1.join(outputDir, `${className}.cls-meta.xml`), sourceApiVersion);
                }
                else {
                    console.log(`No values, skipping: ${valueSetName}`);
                }
            }
        });
    });
}
function generatePicklistClassesFromGlobalValueSets(project, outputDir, include, prefix, suffix, sourceApiVersion) {
    const globalValueSetPaths = find_metadata_1.findFilesByMetadataType("GlobalValueSet", project.path);
    return Promise.all(globalValueSetPaths.map(salesforce_metadata_1.readMetadataXML))
        .then((sets) => {
        console.log("Building constant classes from global value sets.");
        sets.forEach((it, idx) => {
            const setPath = globalValueSetPaths[idx];
            const valueSetName = pathToMetadataName(setPath, "globalValueSets", "\.globalValueSet-meta\.xml");
            if (!valueSetName) {
                throw Error(`Couldn't parse global value set name from path ${setPath}`);
            }
            if (!include || include.includes(valueSetName)) {
                const availableLength = APEX_CLASS_NAME_MAX_LEN - (prefix.length + suffix.length);
                const baseName = valueSetName.substring(0, availableLength);
                const className = `${prefix}${baseName}${suffix}`;
                const content = buildApexClassContentFromGlobalValueSet(it.GlobalValueSet, valueSetName, className);
                if (content) {
                    writeApexClassFile(path_1.join(outputDir, `${className}.cls`), content);
                    writeApexClassMetaFile(path_1.join(outputDir, `${className}.cls-meta.xml`), sourceApiVersion);
                }
                else {
                    console.log(`No values, skipping: ${valueSetName}`);
                }
            }
        });
    });
}
function writeApexClassFile(path, content) {
    fs_extra_1.default.ensureFileSync(path);
    fs_extra_1.default.writeFileSync(path, content);
}
function buildApexClassContentFromStandardValueSet(valueSet, valueSetName, className) {
    const values = valueSet.standardValue || [];
    const properties = values.filter(it => it.fullName).map(it => {
        // tslint:disable-next-line:no-non-null-assertion
        const fullName = it.fullName[0];
        const propertyName = ensureValidApexPropertyName(fullName).toUpperCase();
        const value = fullName.replace("'", "\\'");
        return `\tpublic static final String ${propertyName} = '${value}';`;
    });
    const classHeader = `/**\n * ${valueSetName} standard value set.\n */\n`;
    return properties.length === 0 ? undefined : `${notice_1.apexNotice()}\n${classHeader}public inherited sharing class ${className} {\n\n${properties.join("\n")}\n}`;
}
function buildApexClassContentFromGlobalValueSet(valueSet, valueSetName, className) {
    const values = valueSet.customValue || [];
    const properties = values.filter(it => it.fullName).map(it => {
        // tslint:disable-next-line:no-non-null-assertion
        const fullName = it.fullName[0];
        const propertyName = ensureValidApexPropertyName(fullName).toUpperCase();
        const value = fullName.replace("'", "\\'");
        return `\tpublic static final String ${propertyName} = '${value}';`;
    });
    const classHeader = `/**\n * ${valueSetName} global value set.\n */\n`;
    return properties.length === 0 ? undefined : `${notice_1.apexNotice()}\n${classHeader}public inherited sharing class ${className} {\n\n${properties.join("\n")}\n}`;
}
function buildApexClassContentFromPicklistField(customField, objectName, className) {
    const valueSets = customField.valueSet;
    const valueSet = valueSets ? valueSets[0] : undefined;
    const definition = (valueSet === null || valueSet === void 0 ? void 0 : valueSet.valueSetDefinition) ? valueSet.valueSetDefinition[0] : undefined;
    const value = (definition === null || definition === void 0 ? void 0 : definition.value) ? definition.value : undefined;
    const properties = (value || []).filter(it => it.fullName).map((it) => {
        // tslint:disable-next-line:no-non-null-assertion
        const fullName = it.fullName[0];
        const propertyName = ensureValidApexPropertyName(fullName).toUpperCase();
        const propertyValue = fullName.replace("'", "\\'");
        return `\tpublic static final String ${propertyName} = '${propertyValue}';`;
    });
    const classHeader = `/**\n * ${objectName}.${customField.fullName} custom field value set.\n */\n`;
    return properties.length === 0 ? undefined : `${notice_1.apexNotice()}\n${classHeader}public inherited sharing class ${className} {\n\n${properties.join("\n")}\n}`;
}
function writeApexClassMetaFile(path, apiVersion) {
    const data = {
        ApexClass: {
            $: {
                xmlns: "http://soap.sforce.com/2006/04/metadata"
            },
            // @ts-ignore
            apiVersion: apiVersion,
            status: ["Active"]
        }
    };
    salesforce_metadata_1.writeMetadataXML(path, data);
}
function ensureValidApexPropertyName(it) {
    // The name can only contain characters, letters, and the underscore (_) character, must start with a letter,
    // and cannot end with an underscore or contain two consecutive underscore characters.
    const result = it.replace(/[^\w]+/g, "_")
        .replace(/_$/, "");
    const apexReservedWords = [
        "final", "static", "instanceof", "super", "this", "transient", "with",
        "without", "sharing", "inherited", "public", "private", "protected", "class", "new"
    ];
    return result.match(/^[a-zA-Z]/) && !apexReservedWords.includes(result.toLowerCase()) ? result : `a_${result}`;
}
function isFieldWithValueSet(customField) {
    return Boolean(customField.type && ["MultiselectPicklist", "Picklist"].includes(customField.type[0]));
}
function pathToMetadataName(path, dirName, suffix) {
    const execResult = slash_1.default(path).match(new RegExp(`.*[/\]${dirName}[/\](.*?)${suffix}`));
    return execResult ? execResult[1] : undefined;
}
function pathToObjectName(path) {
    const execResult = slash_1.default(path).match(/.*[/\\]objects[/\\](.*?)[/\\].*/);
    return execResult ? execResult[1] : undefined;
}
//# sourceMappingURL=picklists.js.map